package fr.restoflash.api.local.android.dao;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
import java.math.BigDecimal;
import java.util.List;
import fr.restoflash.api.model.interfaces.PaymentInterface;
import fr.restoflash.api.model.TokenType;
import fr.restoflash.api.model.interfaces.Token;
import fr.restoflash.api.model.Checkout;
import fr.restoflash.api.model.EanToken;
import fr.restoflash.api.model.QrCode;
import fr.restoflash.api.model.PaymentLog;
import fr.restoflash.api.model.PaymentStatus;
import fr.restoflash.api.util.Divers;
// KEEP INCLUDES END
/**
 * Entity mapped to table "SERIALIZABLE_PAYMENT".
 */
public class SerializablePayment implements PaymentInterface {

    /** Not-null value. */
    private String uniqueId;
    /** Not-null value. */
    private String tokenTypeString;
    /** Not-null value. */
    private java.util.Date creationDate;
    private java.util.Date confirmDate;
    private java.util.Date processedDate;
    private String reference;
    private String statusString;
    private String resultId;
    private String errorId;
    private String errorMessage;
    private String tokenText;
    private Integer askedAmountCentimes;
    private Integer amountToCancelCentimes;
    private Integer amountCancelledCentimes;
    private Boolean acceptPartial;
    private String logsString;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient SerializablePaymentDao myDao;

    private SerializableTransaction transactionResult;
    private String transactionResult__resolvedKey;


    // KEEP FIELDS - put your custom fields here
    private Token token;
    //ajouter getToken() à la fin du contructeur généré
    // KEEP FIELDS END

    public SerializablePayment() {
    }

    public SerializablePayment(String uniqueId) {
        this.uniqueId = uniqueId;
    }

    public SerializablePayment(String uniqueId, String tokenTypeString, java.util.Date creationDate, java.util.Date confirmDate, java.util.Date processedDate, String reference, String statusString, String resultId, String errorId, String errorMessage, String tokenText, Integer askedAmountCentimes, Integer amountToCancelCentimes, Integer amountCancelledCentimes, Boolean acceptPartial, String logsString) {
        this.uniqueId = uniqueId;
        this.tokenTypeString = tokenTypeString;
        this.creationDate = creationDate;
        this.confirmDate = confirmDate;
        this.processedDate = processedDate;
        this.reference = reference;
        this.statusString = statusString;
        this.resultId = resultId;
        this.errorId = errorId;
        this.errorMessage = errorMessage;
        this.tokenText = tokenText;
        this.askedAmountCentimes = askedAmountCentimes;
        this.amountToCancelCentimes = amountToCancelCentimes;
        this.amountCancelledCentimes = amountCancelledCentimes;
        this.acceptPartial = acceptPartial;
        this.logsString = logsString;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getSerializablePaymentDao() : null;
    }

    /** Not-null value. */
    public String getUniqueId() {
        return uniqueId;
    }

    /** Not-null value; ensure this value is available before it is saved to the database. */
    public void setUniqueId(String uniqueId) {
        this.uniqueId = uniqueId;
    }

    /** Not-null value. */
    public String getTokenTypeString() {
        return tokenTypeString;
    }

    /** Not-null value; ensure this value is available before it is saved to the database. */
    public void setTokenTypeString(String tokenTypeString) {
        this.tokenTypeString = tokenTypeString;
    }

    /** Not-null value. */
    public java.util.Date getCreationDate() {
        return creationDate;
    }

    /** Not-null value; ensure this value is available before it is saved to the database. */
    public void setCreationDate(java.util.Date creationDate) {
        this.creationDate = creationDate;
    }

    public java.util.Date getConfirmDate() {
        return confirmDate;
    }

    public void setConfirmDate(java.util.Date confirmDate) {
        this.confirmDate = confirmDate;
    }

    public java.util.Date getProcessedDate() {
        return processedDate;
    }

    public void setProcessedDate(java.util.Date processedDate) {
        this.processedDate = processedDate;
    }

    public String getReference() {
        return reference;
    }

    public void setReference(String reference) {
        this.reference = reference;
    }

    public String getStatusString() {
        return statusString;
    }

    public void setStatusString(String statusString) {
        this.statusString = statusString;
    }

    public String getResultId() {
        return resultId;
    }

    public void setResultId(String resultId) {
        this.resultId = resultId;
    }

    public String getErrorId() {
        return errorId;
    }

    public void setErrorId(String errorId) {
        this.errorId = errorId;
    }

    public String getErrorMessage() {
        return errorMessage;
    }

    public void setErrorMessage(String errorMessage) {
        this.errorMessage = errorMessage;
    }

    public String getTokenText() {
        return tokenText;
    }

    public void setTokenText(String tokenText) {
        this.tokenText = tokenText;
    }

    public Integer getAskedAmountCentimes() {
        return askedAmountCentimes;
    }

    public void setAskedAmountCentimes(Integer askedAmountCentimes) {
        this.askedAmountCentimes = askedAmountCentimes;
    }

    public Integer getAmountToCancelCentimes() {
        return amountToCancelCentimes;
    }

    public void setAmountToCancelCentimes(Integer amountToCancelCentimes) {
        this.amountToCancelCentimes = amountToCancelCentimes;
    }

    public Integer getAmountCancelledCentimes() {
        return amountCancelledCentimes;
    }

    public void setAmountCancelledCentimes(Integer amountCancelledCentimes) {
        this.amountCancelledCentimes = amountCancelledCentimes;
    }

    public Boolean getAcceptPartial() {
        return acceptPartial;
    }

    public void setAcceptPartial(Boolean acceptPartial) {
        this.acceptPartial = acceptPartial;
    }

    public String getLogsString() {
        return logsString;
    }

    public void setLogsString(String logsString) {
        this.logsString = logsString;
    }

    /** To-one relationship, resolved on first access. */
    public SerializableTransaction getTransactionResult() {
        String __key = this.resultId;
        if (transactionResult__resolvedKey == null || transactionResult__resolvedKey != __key) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            SerializableTransactionDao targetDao = daoSession.getSerializableTransactionDao();
            SerializableTransaction transactionResultNew = targetDao.load(__key);
            synchronized (this) {
                transactionResult = transactionResultNew;
            	transactionResult__resolvedKey = __key;
            }
        }
        return transactionResult;
    }

    public void setTransactionResult(SerializableTransaction transactionResult) {
        synchronized (this) {
            this.transactionResult = transactionResult;
            resultId = transactionResult == null ? null : transactionResult.getId();
            transactionResult__resolvedKey = resultId;
        }
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here
    public SerializablePayment(PaymentInterface p) {
        this.uniqueId = p.getUniqueId();
        this.tokenTypeString= p.getTokenType().name();
        this.creationDate = p.getCreationDate();
        this.confirmDate = p.getConfirmDate();
        this.processedDate = p.getProcessedDate();
        this.reference = p.getReference();
        this.statusString = p.getStatus().name();
        if(p.getTransactionResult()!=null)
            this.transactionResult = new SerializableTransaction(p.getTransactionResult());
        this.errorId = p.getErrorId();
        this.errorMessage = p.getErrorMessage();
        this.token = p.getToken();
        if(p.getToken()!=null)
             this.tokenText = p.getToken().getTokenText();
        if(p.getAskedAmount()!=null)
             this.askedAmountCentimes = p.getAskedAmount().multiply(new BigDecimal(100)).intValue();
        if(p.getAmountToCancel()!=null)
            this.amountToCancelCentimes = p.getAmountToCancel().multiply(new BigDecimal(100)).intValue();
        if(p.getAmountCancelled()!=null)
            this.amountCancelledCentimes = p.getAmountCancelled().multiply(new BigDecimal(100)).intValue();
        this.acceptPartial = p.isAcceptPartial();
    }

    @Override
    public PaymentStatus getStatus() {
        PaymentStatus retValue = PaymentStatus.valueOf(statusString);
        return retValue;
    }
    @Override
    public BigDecimal getAskedAmount() {
        return new BigDecimal(askedAmountCentimes).divide(new BigDecimal(100)).setScale(2, BigDecimal.ROUND_HALF_UP);
    }

    @Override
    public BigDecimal getAmountToCancel()
    {
        return new BigDecimal(amountToCancelCentimes).divide(new BigDecimal(100)).setScale(2,BigDecimal.ROUND_HALF_UP);
    }

    @Override
    public BigDecimal getAmountCancelled() {
        return  new BigDecimal(amountCancelledCentimes).divide(new BigDecimal(100)).setScale(2,BigDecimal.ROUND_HALF_UP);
    }

    @Override
    public List<PaymentLog> getLog() {
        return Divers.logsFromString(logsString);
    }

    @Override
    public TokenType getTokenType() {
        TokenType retValue = TokenType.valueOf(tokenTypeString);
        return retValue;
    }

    @Override
    public Token getToken() {
        if(token==null && tokenText!=null)
        {
            switch(getTokenType())
            {
                case QRCODE:
                    token = QrCode.from(tokenText);
                    break;
                case CHECKOUT:
                    token = Checkout.fromText(tokenText);
                    break;
                case EAN:
                    token = EanToken.fromText(tokenText);
                    break;
            }
        }
        return token;
    }
    @Override
    public boolean isAcceptPartial()
    {
        return getAcceptPartial();
    }
    // KEEP METHODS END

}
